/*
 * Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at
 * the Lawrence Livermore National Laboratory. Written by Keith Stevens,
 * kstevens@cs.ucla.edu OCEC-10-073 All rights reserved. 
 *
 * This file is part of the C-Cat package and is covered under the terms and
 * conditions therein.
 *
 * The S-Space package is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation and distributed hereunder to you.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND NO REPRESENTATIONS OR WARRANTIES,
 * EXPRESS OR IMPLIED ARE MADE.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, WE MAKE
 * NO REPRESENTATIONS OR WARRANTIES OF MERCHANT- ABILITY OR FITNESS FOR ANY
 * PARTICULAR PURPOSE OR THAT THE USE OF THE LICENSED SOFTWARE OR DOCUMENTATION
 * WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER
 * RIGHTS.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package edu.ucla.sspace.wordsi;

import edu.ucla.sspace.dependency.DependencyPath;
import edu.ucla.sspace.dependency.DependencyPathAcceptor;
import edu.ucla.sspace.dependency.DependencyPathWeight;
import edu.ucla.sspace.dependency.DependencyTreeNode;
import edu.ucla.sspace.dependency.FilteredDependencyIterator;

import edu.ucla.sspace.dv.DependencyPathBasisMapping;

import edu.ucla.sspace.vector.CompactSparseVector;
import edu.ucla.sspace.vector.SparseDoubleVector;

import java.util.Iterator;

/**
 * A {@link DependencyContextGenerator} that forms co-occurrence context vectors
 * from words that are reachable via a valid {@link DependencyPath} from a focus
 * term.
 *
 * @author Keith Stevens
 */
public class WordOccrrenceDependencyContextGenerator
        implements DependencyContextGenerator {

    /**
     * A basis mapping from dependency paths to the the dimensions that
     * represent the content of those paths.
     */
    private final DependencyPathBasisMapping basisMapping;

    /**
     * A function that weights {@link DependencyPath} instances according to
     * some criteria.
     */
    private final DependencyPathWeight weighter;

    /**
     * The maximum acceptable {@link DependencyPath} length.
     */
    private final int pathLength;

    /**
     * The filter that accepts only dependency paths that match predefined
     * criteria.
     */
    private final DependencyPathAcceptor acceptor;

    /**
     * Creates a new {@link WordOccrrenceDependencyContextGenerator}
     *
     * @param basisMapping A mapping from word forms to their feature indices
     * @param weighter A weight function applied to each {@link DependencyPath}
     * @param acceptor An acceptor that rejects invalid {@link DependencyPath}
     * @param pathLength The maximum length for a valid {@link DependencyPath}
     */
    public WordOccrrenceDependencyContextGenerator(
            DependencyPathBasisMapping basisMapping,
            DependencyPathWeight weighter,
            DependencyPathAcceptor acceptor,
            int pathLength) {
        this.basisMapping = basisMapping;
        this.weighter = weighter;
        this.acceptor = acceptor;
        this.pathLength = pathLength;
    }

    /**
     * {@inheritDoc}
     */
    public SparseDoubleVector generateContext(DependencyTreeNode[] tree,
                                              int focusIndex) {
        DependencyTreeNode focusNode = tree[focusIndex];

        SparseDoubleVector focusMeaning = new CompactSparseVector();
        // Get all the valid paths starting from this word. 
        Iterator<DependencyPath> paths = new FilteredDependencyIterator(
                focusNode, acceptor, pathLength);
            
        // For each of the paths rooted at the focus word, update the
        // co-occurrences of the focus word in the dimension that the
        // BasisFunction states with the weight generated by the
        // DependencyPathWeight function.
        while (paths.hasNext()) {
            DependencyPath path = paths.next();

            // Get the dimension from the basis mapping, ignore any features
            // that are not mapped.
            int dimension = basisMapping.getDimension(path);
                if (dimension < 0)
                    continue;

            double weight = weighter.scorePath(path);
            focusMeaning.add(dimension, weight);                                        
        }
        return focusMeaning;
    }

    /**
     * {@inheritDoc}
     */
    public int getVectorLength() {
        return basisMapping.numDimensions();
    }

    /**
     * {@inheritDoc}
     */
    public void setReadOnly(boolean readOnly) {
        basisMapping.setReadOnly(readOnly);
    }
}
